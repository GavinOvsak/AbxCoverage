<html>
<head>
  <title>Abx Coverage</title>
  <script src="/res/js/jquery-2.2.4.js"></script>
  <script src="/res/js/jquery-ui.js"></script>
  <script src="/res/js/popper.min.js"></script>
  <script src="/res/js/bootstrap.min.js"></script>
  <script src="/res/js/lodash.min.js"></script>
  <script src="/res/js/awesomplete.js"></script>
  <script async src="/res/js/lodash.min.js"></script>
  <script src="/res/js/fontawesome.js"></script>
  <script src="/res/js/utilities.js"></script>
  <script src="/data/abxList.js"></script>
  <script src="/data/bugList.js"></script>
  <script src="/data/conditionList.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="icon" type="image/png" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="favicon.ico">
  <link rel="stylesheet" href="/res/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="/res/css/awesomplete.css">
  <style>
    .btn:focus { outline:none; }
    .bigBugBox {
      margin-bottom: 15px;
    }
    .bugRow {
      padding: 6px;
      border-radius: 5px;
      width: 250px;
      margin-bottom: 5px;
      margin-right: 5px;
      cursor: pointer;
    }
    .abxRow {
      width: calc(100% - 5px);
      display: inline-block;
      margin-bottom: 5px;
      background-color: #e8e8e8;
      border-radius: 5px;
      padding: 5px;
      text-align: center;
      cursor: pointer;
    }
    .abxHeader {
      overflow-x: scroll;
      display: inline-block;
      white-space: nowrap;
      width: calc(100% - 10px);
    }
  </style>
</head>
<body style="user-select: none;">
  <div id="topBar" style="width: 100%; display: inline-block;">
    <span id="titleAndButtons" style="padding-left: 10px;display: inline-block;width: 100%;padding-top: 7px;vertical-align: top;background-color: #0c7bff;color: white;padding-bottom: 5px;">
      <h3 style="display: inline-block;line-height: 35px;position: relative;top: -4px;vertical-align: top;margin-top: 3px;margin-bottom: 5px;margin-right: 10px;" aria-haspopup="true" aria-expanded="true">
        <span id="mainTitle" style="vertical-align: text-top;">
          <a href="/" style="color: white; text-decoration: none;">Antimicrobial Coverage</a>
        </span>
      </h3>
      <a href="mailto:ovsak.gavin@gmail.com"><div class="btn btn-light" style="float: right;margin-right: 5px;margin-bottom: 5px;">Feedback</div></a>
      <span style="float: right;">
        <h5 style="display: inline-block;margin-right: 10px;">Antibiogram: </h5>
        <select id="antibiogram" class="form-control" style="width: auto; display: inline-block; margin-right: 10px;">
          <option value="BWH">BWH</option>
          <option value="General">General</option>
        </select>
      </span>
      <span id="loadingTitle" style="margin-left: 10px; position: relative; top: -3px; display: none;"> Loading.. </span>
    </span>
  </div>
  <div id="mainBar" class="bg loading" style="float: left;width: 100%;height: calc(100% - 50px);background-color: white;">
    <!-- <div id="mobileTop" style="width: 100%; background-color: lightgrey; text-align: center; font-size: 21px; display: none;">
      <div class="btn-sm btn btn-light mobileTab" data-type="bug" style="margin-top: 9px;margin-bottom: 5px;float: left;margin-left: 5px;margin-right: 5px;"><i class="fas fa-bug" style="margin-right: 8px;" aria-hidden="true"></i>Bugs</div><div style="display: inline-block;width: calc(100% - 165px);margin-top: 6px;margin-bottom: 5px;">
        <div class="input-group">
          <input id="mixedSearch" type="text" class="form-control" placeholder="Search" aria-label="Recipient's username" aria-describedby="basic-addon2">
          <div id="mixedAddons" class="input-group-append">
            <button class="btn btn-primary routeToggle" data-type="IV" type="button" style="padding-left: 8px; padding-right: 8px;">IV</button>
            <button class="btn btn-primary routeToggle" data-type="PO" type="button" style="padding-left: 8px; padding-right: 8px;">PO</button>
          </div>
        </div>
      </div>
      <div class="btn-sm btn btn-light mobileTab" data-type="abx" style="margin-top: 9px;margin-bottom: 5px;float: left;margin-left: 5px;margin-right: 5px;float: right;"><i class="fas fa-capsules" style="margin-right: 8px;" aria-hidden="true"></i>Abx</div>
    </div> -->
    <div id="bugCol" style="width: 100%;display: inline-block;vertical-align: top;border-right: black solid 1px;padding-bottom: 10px;height: 50%;"> 
      <div id="bugTop" style="width: 100%;background-color: lightgrey;padding: 5px;cursor: pointer;display: inline-block;">
        <i class="fas fa-bug" style="margin-right: 10px;width: 16px;display: inline-block;margin-left: 5px;" aria-hidden="true"></i>
        <span style="display: inline-block; margin-right: 5px;">Bug Targets</span>
        <div style="display: inline-block;width: calc(100% - 203px);max-width: 302px;">
          <input id="bugSearch" class="form-control" placeholder="Search Bugs / Conditions" >
        </div>
        <div id="resetBugs" class="btn btn-light" style="vertical-align: top;">Reset</div>
      </div>
      <div id="bugList" style="overflow-y: scroll;height: calc(100% - 44px);flex-direction: column;flex-wrap: wrap;padding-top: 5px;padding-left: 5px;align-content: flex-start;display: flex;"></div>
    </div><div id="abxCol" style="width: 34%; display: none; vertical-align: top;"> 
      <div id="abxTop" style="width: 100%;background-color: lightgrey;padding: 5px 0px;cursor: pointer;display: inline-block;">
        <i class="fas fa-capsules" style="margin-right: 10px;width: 14px;display: inline-block;margin-left: 10px;" aria-hidden="true"></i>
        <span style="display: inline-block;margin-right: 8px;">Abx</span>
        <div style="display: inline-block;width: calc(100% - 128px);">
          <div class="input-group">
            <input id="abxSearch" type="text" class="form-control" placeholder="Search">
            <div class="input-group-append">
              <button class="btn btn-primary routeToggle" data-type="IV" type="button" style="padding-left: 8px; padding-right: 8px;">IV</button>
              <button class="btn btn-primary routeToggle" data-type="PO" type="button" style="padding-left: 8px; padding-right: 8px;">PO</button>
            </div>
          </div>
        </div>
        <div id="contraToggle" class="btn-outline-dark btn" style="padding: 10px;margin-right: 5px;vertical-align: top;">
          <i class="fas fa-biohazard"></i>
        </div>
      </div>
      <div id="abxList" style="overflow-y: scroll;height: calc(100% - 296px);padding-left: 5px;padding-top: 5px;">
      </div>
    </div>
  </div>

  <div id="contraModal" data-keyboard="false" class="modal fade" role="dialog" style="overflow: hidden">
    <div class="modal-dialog modal-lg" style="overflow-y: initial !important;">
      <div class="modal-content">
        <div class="modal-header" style="display: inline-block;">
          <i class="fas fa-biohazard" style="margin-right: 10px;width: 14px;display: inline-block;" aria-hidden="true"></i>
          <span style="display: inline-block;margin-right: 3px;">Contraindications</span>
          <div style="display: inline-block;width: calc(100% - 200px);">
            <input id="contraSearch" type="text" class="form-control" placeholder="Search to Add">
          </div>
          <span data-dismiss="modal" class="fas fa-xmark" style="font-size: 24px;float: right;cursor: pointer;margin-top: 5px;margin-right: 5px;" aria-hidden="true"></span>
        </div>
        <div id="contraList" class="modal-body" style="display: inline-block; padding-top: 20px; width: 100%; overflow-y: scroll; max-height: 722px;"></div>
      </div>
    </div>
  </div>

  <script>

    // var pane = 'bug';
    var panes = null;
    var focusPane = 'bug';

    var openBugGroups = {};
    var targetBugs = {};
    var abxRoutes = { 'IV': true, 'PO': false };

    var abxResults = [];
    var selectedContraList = [];

    var selectedCondition = null;
    var selectedAbx = null;
    var pinnedAbx = {};

    var bugBox = null;
    var abxBox = null;
    var contraBox = null;
    // var mixedBox = null;

    var antibiogram = 'General';

    var getProp = function(that, prop) {
      return $(that).closest('[data-'+prop+']').attr('data-'+prop);
    };

    var setMaxHeight = function(element) {
      var headerBox = $(element+' .modal-header').length != 0 ? $(element+' .modal-header')[0].getBoundingClientRect() : {height: 0, top: 0};
      var footerBox = $(element+' .modal-footer').length != 0 ? $(element+' .modal-footer')[0].getBoundingClientRect() : {height: 20};
      var maxHeight = $(element+'').height() - (Math.max(headerBox.top, 10) + headerBox.height + footerBox.height + 20);
      $(element+' .modal-body').css('max-height', maxHeight);
    };

    var bugJumps = {};
    var bugPaths = {};
    var abxJumps = {};
    var shownBugs = {};

    var resetData = function() {
      var bugSearchList = [];
      addToBugList(bugList, bugSearchList, [], true);
      bugBox.list = bugSearchList.concat(conditionList);;

      abxList[antibiogram].map(function(abxObj) {
        abxJumps[abxObj.name] = abxObj;
      });
    };

    var addToBugList = function(list, outlist, stack, shown) {
      for (var key in list) {
        bugJumps[key] = list[key];
        if (shown) shownBugs[key] = true;
        var newStack = [key].concat(clone(stack));
        bugPaths[key] = newStack;
        var selectedLevel = newStack.find(function(bugLevel) {
          return targetBugs[bugLevel] != null;
        });
        if (typeof list[key] == 'object') {
          var isOpen = openBugGroups[key] == null ? false : !!openBugGroups[key];
          outlist.push({name: key, type: (isOpen ? 'open' : 'closed') + ' group', stack: newStack, percent: targetBugs[selectedLevel], shown: shown });
          addToBugList(list[key], outlist, newStack, shown && isOpen);
        } else {
          outlist.push({name: key, type: 'normal', stack: newStack, percent: targetBugs[selectedLevel], shown: shown });
        }
      }
    };

    var importFromState = function(state) {
      targetBugs = {};
      if ((state.bugs || '').length > 0) {
        (state.bugs || '').split(',').map(function(bugHash) {
          var splitBug = bugHash.split(':');
          targetBugs[splitBug[0]] = splitBug[1] == null ? 1 : parseFloat(splitBug[1]);
          bugPaths[splitBug[0]].slice(1).map(function(parent) {
            openBugGroups[parent] = true;
          });
        });
      }

      if ((state.routes || '').length > 0) {
        abxRoutes = {};
        (state.routes || '').split(',').map(function(name) {
          abxRoutes[name] = true;
        });
      }

      if ((state.contra || '').length > 0) selectedContraList = (state.contra || '').split(',');

      pinnedAbx = {};
      if ((state.abx || '').length > 0) {
        (state.abx || '').split(',').map(function(name) {
          pinnedAbx[name] = true;
        });
      }
    };

    var updateUrl = function(opts) {
      opts = opts || {};

      var params = {};
      if (keys(targetBugs).length > 0) params.bugs = keys(targetBugs).map(bug => bug + ':' + targetBugs[bug]).join(',');
      if (keys(abxRoutes).filter(n => !!abxRoutes[n]).length > 0) params.routes = keys(abxRoutes).filter(n => !!abxRoutes[n]).join(',');
      if (selectedContraList.length > 0) params.contra = selectedContraList.join(',');
      if (keys(pinnedAbx).length > 0) params.abx = keys(pinnedAbx).join(',');

      window.history[!!opts.replace ? 'replaceState' : 'pushState'](
        params, 'Abx Coverage', '/?' + keys(params).map(param => param + '=' + encodeURIComponent(params[param])).join('&') + '#'
      );
    };

    window.onpopstate = function(e){
      if (e.state != null) {
        importFromState(e.state);
        refresh();
      }
    };

    var refresh = function() {

      $('#antibiogram').empty();
      for (var key in abxList) {
        $('#antibiogram').append($('<option value="'+key+'">'+key+'</option>'));
      }
      $('#antibiogram').val(antibiogram);
      $('#antibiogram').unbind('change').on('change', function() {
        antibiogram = $(this).val();
        resetData();
        refresh();
      });

      resetData();
      var bugItemList = [];
      shownBugs = {};
      addToBugList(bugList, bugItemList, [], true);
      for (var key in targetBugs) if (shownBugs[key] == null) delete targetBugs[key];
      for (var abxName in pinnedAbx) if (abxJumps[abxName] == null) delete pinnedAbx[abxName];

      var anySelected = !isEmpty(targetBugs);

      var getCoveragePercent = function(bugItem, chosenAbxList) {
        if (!empty(bugJumps[bugItem.name])) { // Average over subtypes
          return _.mean(keys(bugJumps[bugItem.name]).map(function(subBug) {
            return getCoveragePercent({
              name: subBug,
              stack: clone(bugItem.stack).concat(subBug)
            }, chosenAbxList);
          }));
        } else {
          var maxCoverage = 0;
          (chosenAbxList || []).filter(function(n) {
            return n != null;
          }).some(function(abxName) {
            var abxObj = abxJumps[abxName];
            var abxCoverageLevel = bugPaths[bugItem.name].find(function(bugLevel) {
              return abxObj.coverage[bugLevel] >= 0;
            });
            if (abxCoverageLevel != null) maxCoverage = Math.max(abxObj.coverage[abxCoverageLevel], maxCoverage);
          });
          return maxCoverage * 100;
        }
      };

      $('#bugList').empty(); 
      var bugListHTML = '';
      bugItemList.map(function(item, i) {
        if (!item.shown) return;
        var coveredByChosen = getCoveragePercent(item, [selectedAbx])
        var coveredByAll = Math.max(coveredByChosen, getCoveragePercent(item, keys(pinnedAbx)));
        // Show fractional coverage when group contains things that are covered

        if (item.stack.length == 1) {
          bugListHTML += (i != 0 ? '</div>' : '') + '<div style="display: inline-block; vertical-align: top;" class="bigBugBox">';
        }

        var bgColor = item.type == 'normal' ? 'lightgrey' : '#e8e8e8';
        var background = coveredByAll == 0 ? 'background-color: '+bgColor+';' :
          'background: linear-gradient(to right, '+
            '#75a3ff '+coveredByChosen+'%, #65d165 '+coveredByChosen+'%,'+
            '#65d165 '+coveredByAll+'%, '+bgColor+' '+coveredByAll+'%);'

        var subNum = 0;
        var checkSubs = function(obj) {
          if (typeof obj === 'boolean') {
            subNum++;
            return;
          }
          for (var subName in obj) checkSubs(obj[subName]);
        };
        checkSubs(bugJumps[item.name]);

        bugListHTML += ''+
        // $('#bugList').append($(''+
`<div class="bugRow${item.type == 'normal' ? ' bugNonGroup' : ' bugGroup'}" data-key="${item.name}" style="margin-left: ${(item.stack.length-1) * 10}px;${background}">
  <div class="bugTarget" data-percent="${item.percent == null ? 0 : item.percent}" style="float: right;cursor: pointer;padding: 5px;margin-right: 0px;">
    ${(item.percent != null && item.percent != 1) ? `<svg height="15" width="15" viewBox="0 0 20 20"><circle r="5" cx="10" cy="10" fill="transparent" stroke="#0c7bff" stroke-width="10" stroke-dasharray="calc(${Math.round(item.percent * 100)} * 31.4 / 100) 31.4"></circle></svg>` :
    `<input type="checkbox" style="height: 16px; width: 16px; cursor: pointer;" ${item.percent != null ? 'checked' : ''}>`}
  </div>
  ${item.type == 'normal' ? '' : `<i class="fas fa-caret-${item.type == 'open group' ? 'down': 'right'}" style="margin-right: 5px;" aria-hidden="true"></i>`}
  <span>${item.name+((!!openBugGroups[item.name] || item.type == 'normal' || targetBugs[item.name] == null) ? '' : ' ('+subNum+')')}</span>
</div>`;//));
      });
      $('#bugList').append($(bugListHTML + '</div>'));


      $('.bugGroup').unbind('click').click(function(e) {
        var key = getProp(this, 'key');
        openBugGroups[key] = !(openBugGroups[key] == null ? false : openBugGroups[key]);
        refresh();
      });

      $('#resetBugs').unbind('click').click(function() {
        targetBugs = {};
        openBugGroups = {};
        updateUrl();
        refresh();
      });

      var toggleBug = function(bug, level) {
        var wasTargetted = false;
        bugPaths[bug].map(function(name) {
          if (targetBugs[name] != null) {
            wasTargetted = true;
            delete targetBugs[name];
          }
        });
        if (!wasTargetted) targetBugs[bug] = level;
        updateUrl();
        refresh();
        var nonPinnedAbx = abxResults.filter(function(n) {
          return pinnedAbx[n.abx.name] == null && (n.abx.cost == null || n.abx.cost == '$');
        });
        if (nonPinnedAbx.length > 0 && keys(pinnedAbx).length == 0) {
          selectedAbx = nonPinnedAbx[0].abx.name; 
          refresh();
        }
      }
      $('.bugNonGroup').unbind('click').on('click', function(e) {
        var key = getProp(this, 'key');
        toggleBug(key, 1);
      });

      $('.bugTarget').unbind('click').on('click', function(e) {
        var key = getProp(this, 'key');
        e.stopPropagation();
        toggleBug(key, 1);
      });

      var targetBugList = bugItemList.filter(function(item) {
        return item.type == 'normal' && item.percent != null;
      });
      var currentCoverage = {};
      targetBugList.map(function(bugItem) {
        var maxCoverage = 0;
        keys(pinnedAbx).some(function(abxName) {
          var abxObj = abxJumps[abxName];
          var abxCoverageLevel = bugPaths[bugItem.name].find(function(bugLevel) {
            return abxObj.coverage[bugLevel] >= 0;
          });
          if (abxCoverageLevel != null) maxCoverage = Math.max(abxObj.coverage[abxCoverageLevel], maxCoverage);
        });
        currentCoverage[bugItem.name] = maxCoverage;
      });

      // All combinations?
      // Take the top from each individually and try combining them?
      // Some may not add

      // If any are worse across the board than any specific other, remove. Otherwise, start with each one and make combinations with any others until they stop adding more coverage.
      // Maybe treat > 80% as good enough for "coverage" of a target bug
      // Remove things which accomplish the goal with less items.



      var allAbxResults = abxList[antibiogram].map(function(abx) {
        if (selectedContraList.some(function(contraName) {
          return (abx.contra || []).indexOf(contraName) >= 0;
        })) return { coverage: [] }; // Avoid contra
        var adminTypes = abx.admin.split(',');
        if (adminTypes.every(function(route) {
          return !abxRoutes[route];
        })) return { coverage: [] }; // No acceptable route

        var generalCoverage = {};
        bugItemList.filter(function(item) {
          return item.type == 'normal';
        }).map(function(bugItem) {
          var abxCoverageLevel = bugItem.stack.find(function(bugLevel) {
            return abx.coverage[bugLevel] >= 0;
          });
          generalCoverage[bugItem.name] = abxCoverageLevel != null ? abx.coverage[abxCoverageLevel] : 0;
        });

        return { abx: abx, generalCoverage: generalCoverage }
      }).filter(function(data) {
        return data.abx != null;
      });
      
      abxResults = allAbxResults.filter(function(data) {
        return targetBugList.some(function(bugItem) {
          return currentCoverage[bugItem.name] == null || data.generalCoverage[bugItem.name] > currentCoverage[bugItem.name];
        }) || !!pinnedAbx[data.abx.name];
      });

      var specificCoverageScore = function(data, targetBugList, relative) {
        var addedWeightedBenefit = 0;
        var maxSpecificCoverage = 0;
        var targetBugNames = {};
        targetBugList.map(function(bugItem) {
          var targetBugName = bugItem.stack.find(function(bugName) {
            return targetBugs[bugName] != null;
          });
          targetBugNames[targetBugName] = true;
          var weight = targetBugs[targetBugName];
          var currentLevel = (currentCoverage[bugItem.name] == null || !relative) ? 0 : currentCoverage[bugItem.name];
          maxSpecificCoverage += weight * (1 - currentLevel);
          var addedBenefit = data.generalCoverage[bugItem.name] == null ? 0 : Math.max(0, data.generalCoverage[bugItem.name] - currentLevel);
          if (addedBenefit > 0) addedWeightedBenefit += weight * addedBenefit;
        });

        var nonTargetMax = 0;
        var nonTargetOverlap = 0;
        for (var bugName in data.generalCoverage) {
          if (targetBugNames[bugName] == null) {
            nonTargetOverlap += data.generalCoverage[bugName];
            nonTargetMax += 1;
          }
        }

        return -1 * (addedWeightedBenefit/maxSpecificCoverage) + (nonTargetOverlap / nonTargetMax) / 2;
      };

      // Get best abx for each target bug
      var individualTops = {};
      targetBugList.map(function(bugItem, i) {
        var bugTops = _.sortBy(allAbxResults.filter(function(n) {
          return n.abx.cost == null || n.abx.cost == '$';
        }), function(data) {
          return specificCoverageScore(data, [bugItem], false);
        });
        individualTops[bugTops[0].abx.name] = bugTops[0];

        // Consider top for any two?
        // targetBugList.slice(i+1).map(function(otherBugItem, j) {
        //   var bugTops = _.sortBy(allAbxResults.filter(function(n) {
        //     return n.abx.cost == null || n.abx.cost == '$';
        //   }), function(data) {
        //     return specificCoverageScore(data, [bugItem, otherBugItem], false);
        //   });
        //   individualTops[bugTops[0].abx.name] = bugTops[0];
        // });
      });

      var removeRedundancies = function(list) {
        return _.uniqBy(list.filter(function(comboItem, i) {
          // No other combo covers the same with less
          return !list.some(function(otherComboItem, o_i) {
            return o_i != i && keys(otherComboItem).length < keys(comboItem).length && keys(otherComboItem).every(n => comboItem[n] != null);
          });
        }), function(comboItem) {
          return _.sortBy(keys(comboItem)).join(',');
        });
      }

      var thresh = 0.8; // More than this coverage is acceptable
      var abxCombinations = [];
      for (var abxName in individualTops) {
        var item = individualTops[abxName];
        var coverage = {};
        var combos = [{
          [item.abx.name]: item
        }];
        targetBugList.map(function(bugItem) {
          if (item.generalCoverage[bugItem.name] <= thresh) {
            var newCombos = [];
            var addAbx = keys(individualTops).filter(function(otherAbxName) {
              return individualTops[otherAbxName].generalCoverage[bugItem.name] > thresh && otherAbxName != item.abx.name;
            });
            combos.map(function(comboItem) {
              // If combo already covered this, skip and leave as is
              if (keys(comboItem).some(function(comboItemName) {
                return individualTops[comboItemName].generalCoverage[bugItem.name] > thresh;
              })) return newCombos.push(comboItem);
              addAbx.map(function(otherAbxName) {
                var newCombo = clone(comboItem);
                newCombo[otherAbxName] = individualTops[otherAbxName];
                newCombos.push(newCombo);
              });
            });
            combos = newCombos;
          }
        });
        abxCombinations = abxCombinations.concat(removeRedundancies(combos));
        abxCombinations = removeRedundancies(abxCombinations);
      }

      // abxCombinations.push({
      //   'Vancomycin': allAbxResults.find(n => n.abx.name == 'Vancomycin'),
      //   'Cefepime': allAbxResults.find(n => n.abx.name == 'Cefepime')
      // });

      console.log({individualTops, allAbxResults, abxCombinations});

      // Only top 3 combos
      abxResults = abxResults.concat(_.sortBy(abxCombinations.filter(function(combo) {
        return keys(combo).length > 1;
      }).map(function(combo) {
        var list = _.values(combo);
        var allIV = list.every(n => n.abx.admin.split(',').indexOf('IV') >= 0);
        var allPO = list.every(n => n.abx.admin.split(',').indexOf('PO') >= 0);
        var newOption = {
          abx: {
            name: list.map(n => n.abx.name).join(' + '),
            admin: [allIV ? 'IV': null, allPO ? 'PO' : null].filter(n => n != null).join(','), 
            cost: _.maxBy(list.map(n => n.abx.cost), n => (n || '').length), 
            coverage: {}
          },
          generalCoverage: {}
        };
        abxJumps[newOption.abx.name] = newOption.abx;

        list.map(function(abxItem) {
          for (var bug in abxItem.abx.coverage) {
            if (newOption.abx.coverage[bug] == null || abxItem.abx.coverage[bug] > newOption.abx.coverage[bug]) newOption.abx.coverage[bug] = abxItem.abx.coverage[bug];
          }
          for (var bug in abxItem.generalCoverage) {
            if (newOption.generalCoverage[bug] == null || abxItem.generalCoverage[bug] > newOption.generalCoverage[bug]) newOption.generalCoverage[bug] = abxItem.generalCoverage[bug];
          }
        });

        return newOption;
      }), function(data) {
        return specificCoverageScore(data, targetBugList, pinnedAbx[data.abx.name] == null);
      }).slice(0,3));

      var anyRemoved = false;
      keys(pinnedAbx).concat([selectedAbx]).map(function(abxName) {
        if (abxName != null && abxResults.every(function(data) {
          return data.abx.name != abxName;
        })) {
          if (selectedAbx == abxName && !abxBox.opened) {
            selectedAbx = null;
            anyRemoved = true;
          }
          if (pinnedAbx[abxName] != null) {
            delete pinnedAbx[abxName];
            anyRemoved = true;
          }
        }
      });
      if (anyRemoved) {
        updateUrl();
        return refresh();
      }

      $('#abxList').empty();
      abxResults = _.orderBy(abxResults, [function(data) {
        return !!pinnedAbx[data.abx.name] ? -1 : 0;
      }, function(data) {
        var coverageNum = targetBugList.filter(function(bugItem) {
          if (currentCoverage[bugItem.name] != null && currentCoverage[bugItem.name] > 0) return false;
          return data.generalCoverage[bugItem.name] != null && data.generalCoverage[bugItem.name] > 0;
        }).length;
        return -coverageNum;
      }, function(data) {
        // Sort by the weighted added benefit to the targetBugs
        return specificCoverageScore(data, targetBugList, pinnedAbx[data.abx.name] == null);
        
        // return -data.coverage.filter(function(name) {
        //   return currentCoverage.indexOf(name) == -1;
        // }).length;
      }, function(data) { // Discourage broad spectrum drugs if no added benefit
        return _.sum(_.values(data.generalCoverage));
      }]);

      var prevNum = null;
      abxResults.map(function(data) {
        // background-color: #0c7bff; color: white;
        if (pinnedAbx[data.abx.name] == null) {
          var nonCoveredBugs = targetBugList.filter(function(bugItem) {
            if (currentCoverage[bugItem.name] != null && currentCoverage[bugItem.name] > 0) return false;
            return true;
          });
          var coverageBugs = targetBugList.filter(function(bugItem) {
            if (currentCoverage[bugItem.name] != null && currentCoverage[bugItem.name] > 0) return false;
            return data.generalCoverage[bugItem.name] != null && data.generalCoverage[bugItem.name] > 0;
          });
          if (prevNum != coverageBugs.length && coverageBugs.length > 0) {
            $('#abxList').append($('<h6 class="abxHeader">'+(empty(pinnedAbx) ? '' : 'Add ')+'Coverage: '+coverageBugs.length+'/'+nonCoveredBugs.length+'</h6>'));
            prevNum = coverageBugs.length;
          }
        }

        $('#abxList').append($('<div data-name="'+data.abx.name+'" class="abxRow" style="'+(selectedAbx == data.abx.name ? 'background-color: #75a3ff;' : !!pinnedAbx[data.abx.name] ? 'background-color: #65d165' : '')+'">'+
          data.abx.name+(data.abx.cost != null ? ' ('+data.abx.cost+')' : '')+
          '<i class="'+(!!pinnedAbx[data.abx.name] ? 'fas' : 'far')+' fa-bookmark saveAbx" aria-hidden="true" style="float: right;padding: 5px; color: black"></i>'+
        '</div>'));
      });

      if (abxResults.length == 0) {
        $('#abxList').append($('<h6 style="margin: 10px;">First, pick some bugs to target or search for an antibiotic. Then select an antibiotic to see its coverage.<br><br>Sources:<br><a target="_blank" href="https://www.mass.gov/service-details/massachusetts-antibiograms">- Massachusetts Antibiogram</a><br><a target="_blank" href="https://med.stanford.edu/content/dam/sm/bugsanddrugs/documents/clinicalmicrobiology/AntibiogramsCombined/2020-SHC-Antibiogram.pdf">- Stanford Antibiogram</a><br></h6>'));
      }

      // Ideally would show a circle of how much coverage each has

      $('.abxRow').unbind('click').click(function() {
        var name = getProp(this, 'name');
        if (selectedAbx == name) selectedAbx = null;
        else selectedAbx = name;
        refresh();
      });

      $('.saveAbx').unbind('click').click(function(e) {
        var name = getProp(this, 'name');
        if (pinnedAbx[name] != null) delete pinnedAbx[name];
        else pinnedAbx[name] = true;
        selectedAbx = null;
        e.stopPropagation();
        updateUrl();
        refresh();
      });

      var contraList = {};
      abxList[antibiogram].map(function(abx) {
        (abx.contra || []).map(function(contra) {
          contraList[contra] = true;
        });
      });

      if (contraBox != null) {
        contraBox.list = keys(contraList).filter(function(contraName) {
          return selectedContraList.indexOf(contraName) == -1;
        });
      }

      $('#contraList').empty();
      selectedContraList.map(function(contra) {
        $('#contraList').append($('<div data-type="'+contra+'" class="abxRow removeContra">'+contra+'<i class="fa-solid fa-xmark" style="float: right; padding: 5px;"></i></div>'));
      });

      $('#contraToggle').css('color', selectedContraList.length == 0 ? '': '#007bff')

      $('.removeContra').unbind('click').click(function() {
        var type = getProp(this, 'type');
        selectedContraList = selectedContraList.filter(function(n) {
          return n != type;
        });
        updateUrl();
        refresh();
      });
    };

    var updateLayout = function() {
      var width = $(document).innerWidth();
      var height = $(document).innerHeight();

      var oldPanes = panes;
      panes = width > 615 ? 'two' : 'one';
      if (panes != oldPanes) refresh();

      // $('#mobileTop').toggle(panes == 'one');
      $('#bugCol, #abxCol, #bugTop, #abxTop').css('display', 'inline-block');//.css('display', panes != 'one' ? 'inline-block' : 'none');
      if (panes == 'two') { // Two Pane
        $('#bugCol').css('width', 'calc(100% - 335px)').css('height', '100%')
        $('#abxCol').css('width', '335px').css('height', '100%')
        $('#bugList, #abxList').css('height', 'calc(100% - 44px)');
      } else if (panes == 'one') { // One Pane

        if (height < 500) { // Only focus on one. Looks like keyboard shrunk the view.
          $('#bugList, #abxList').css('height', 'calc(100% - 44px)');
          $('#abxCol, #bugCol').css('width', '100%').css('height', '100%');
          if (focusPane == 'bug') $('#abxCol, abxList').hide();
          else if (focusPane == 'abx') $('#bugCol, bugList').hide();

        } else {

          $('#bugCol, #abxCol').css('width', '100%').css('height', '50%')
          $('#bugList, #abxList').css('height', 'calc(100% - 44px)');

        }
        // $('#abxList').css('height', 'calc(100% - 215px)');

        // $('#bugCol, #abxCol').css('width', '100%').css('height', 'calc(100% - 49px)')
        // $('#bugCol').toggle(pane == 'bug');
        // $('#abxCol').toggle(pane == 'abx');
        // $('#bugList').css('height', '100%');
        // $('#abxList').css('height', 'calc(100% - 167px)');
      }

      // $('#mixedAddons').toggle(pane == 'abx');
      // $('#mixedSearch').parent().css('width', pane == 'abx' ? 'calc(100% - 72px)' : '100%');
      // $('#mixedSearch').attr('placeholder', pane == 'abx' ? 'Search Antibiotics' : 'Search Bugs / Conditions');

      // if (panes == 'one') {
      //   if (pane == 'abx') {
      //     mixedBox.list = abxList.filter(function(abx) {
      //       return abx.admin.split(',').some(function(route) {
      //         return !!abxRoutes[route];
      //       });
      //     });;
      //   } else if (pane == 'bug') {
      //     var bugSearchList = [];
      //     addToBugList(bugList, bugSearchList, [], true);
      //     mixedBox.list = bugSearchList.concat(conditionList);
      //   }
      // }

      if (abxBox != null) {
        abxBox.list = abxList[antibiogram].filter(function(abx) {
          return abx.admin.split(',').some(function(route) {
            return !!abxRoutes[route];
          });
        });
      }

      // $('.mobileTab').removeClass('btn-secondary').addClass('btn-light').unbind('click').click(function() {
      //   pane = getProp(this, 'type');
      //   refresh();
      //   updateLayout();
      // });
      // $('.mobileTab[data-type="'+pane+'"]').addClass('btn-secondary').removeClass('btn-light')
      // $('#bodyMain').css('height', panes == 'one' ? '100%' : 'calc(100% - 55px)');

      $('.routeToggle').removeClass('btn-primary').addClass('btn-light').unbind('click').click(function() {
        var type = getProp(this, 'type');
        abxRoutes[type] = !abxRoutes[type];
        if (!abxRoutes['IV'] && !abxRoutes['PO']) abxRoutes = { 'IV': true, 'PO': true };
        updateUrl();
        refresh();
        updateLayout();
        $(this).blur();
      });
      for (var route in abxRoutes) {
        if (!!abxRoutes[route]) $('.routeToggle[data-type="'+route+'"]').addClass('btn-primary').removeClass('btn-light')
      }
    };

    $(function() {

      var showBug = function(value) {
        var includes = value.includes || {};
        if (value.includes == null) includes[value.name] = 1;
        else {
          openBugGroups = {};
          targetBugs = {};
        }
        keys(includes).map(function(bugName) {
          bugPaths[bugName].slice(1).map(function(parent) {
            openBugGroups[parent] = true;
          });
          targetBugs[bugName] = includes[bugName];
        });
        updateUrl();
        refresh();
        var nonPinnedAbx = abxResults.filter(function(n) {
          return pinnedAbx[n.abx.name] == null && (n.abx.cost == null || n.abx.cost == '$');
        });
        if (nonPinnedAbx.length > 0) {
          selectedAbx = nonPinnedAbx[0].abx.name; 
          refresh();
        }
      };

      $('#bugSearch').unbind('focus').on('focus', function() {
        focusPane = 'bug';
        console.log('focused on ', focusPane);
      });

      // Combination of bugs and conditions
      bugBox = new Awesomplete($('#bugSearch')[0], {
        list: [], minChars: 0, autoFirst: true, maxItems: 8,
        data: function(item) {
          return { label: item.name, value: item };
        }
      });
      bugBox.container.addEventListener("awesomplete-selectcomplete", function(data) {
        $('#bugSearch').val('');
        var value = data.text.value;
        showBug(value);
      });

      resetData();

      // var bugSearchList = [];
      // addToBugList(bugList, bugSearchList, [], true);
      // bugBox.list = bugSearchList.concat(conditionList);;

      $('#abxSearch').unbind('focus').on('focus', function() {
        focusPane = 'abx';
        console.log('focused on ', focusPane);
      });

      abxBox = new Awesomplete($('#abxSearch')[0], {
        list: [], minChars: 0, autoFirst: true, maxItems: 8,
        data: function(item) {
          return { label: item.name, value: item };
        }
      });
      abxBox.container.addEventListener("awesomplete-selectcomplete", function(data) {
        $('#abxSearch').val('');
        var value = data.text.value;
        pinnedAbx[value.name] = true;
        selectedAbx = null;
        updateUrl();
        refresh();
      });
      abxBox.container.addEventListener("awesomplete-highlight", function(data) {
        var value = data.text.value;
        selectedAbx = value.name;
        refresh();
      });

      // abxList[antibiogram].map(function(abxObj) {
      //   abxJumps[abxObj.name] = abxObj;
      // });

      contraBox = new Awesomplete($('#contraSearch')[0], {
        list: [], minChars: 0, autoFirst: true, maxItems: 8,
        data: function(item) {
          return { label: item.label, value: item };
        }
      });
      $('#contraSearch').click(function() {
        contraBox.evaluate();
      });

      contraBox.container.addEventListener("awesomplete-selectcomplete", function(data) {
        $('#contraSearch').val('');
        var value = data.text.value;
        if (selectedContraList.indexOf(value) == -1) selectedContraList.push(value);
        updateUrl();
        refresh();
      });

      $('#bugSearch, #contraSearch').parent().css('width', '100%');
      $('#abxSearch').parent().css('width', 'calc(100% - 72px)');

      // mixedBox = new Awesomplete($('#mixedSearch')[0], {
      //   list: [], minChars: 0, autoFirst: true, maxItems: 8,
      //   data: function(item) {
      //     return { label: item.name, value: item };
      //   }
      // });
      // mixedBox.container.addEventListener("awesomplete-selectcomplete", function(data) {
      //   $('#mixedSearch').val('');
      //   var value = data.text.value;
      //   if (pane == 'abx') {
      //     pinnedAbx[value.name] = true;
      //     selectedAbx = null;
      //   } else if (pane == 'bug') {
      //     showBug(value);
      //   }
      //   refresh();
      // });
      // $('#mixedSearch').parent().css('font-size','16px');

      $('#contraToggle').unbind('click').click(function() {
        $('#contraModal').modal({ show: true });
        setTimeout(function() {
          setMaxHeight('#contraModal');
        }, 200);
      });

      $('[data-toggle="tooltip"]').tooltip();

      $(document).keydown(function(e){
        if (e.which == 40) { // Down
          if (selectedAbx != null) {
            var newIndex = abxResults.findIndex(function(data) {
              return data.abx.name == selectedAbx;
            }) + 1;
            if (abxResults[newIndex] != null) selectedAbx = abxResults[newIndex].abx.name;
            refresh();
          }
          return false;
        } else if (e.which == 38) { // Up
          if (selectedAbx != null) {
            var newIndex = abxResults.findIndex(function(data) {
              return data.abx.name == selectedAbx;
            }) - 1;
            if (abxResults[newIndex] != null) selectedAbx = abxResults[newIndex].abx.name;
            refresh();
          }
          return false;
        }
      }); 

      // $('#surgerySearch, #blockSearch').parent().css('width', 'calc(100% - 10px)');
      // $('#surgerySearch, #blockSearch').parent().find('ul').css('margin-left', '5px');

      var state = {
        bugs: getParameterByName('bugs'),
        routes: getParameterByName('routes'),
        abx: getParameterByName('abx'),
        contra: getParameterByName('contra'),
      };
      importFromState(state);
      updateUrl({ replace: true });
      updateLayout();
      var nonPinnedAbx = abxResults.filter(function(n) {
        return pinnedAbx[n.abx.name] == null && (n.abx.cost == null || n.abx.cost == '$');
      });
      if (nonPinnedAbx.length > 0 && keys(pinnedAbx).length == 0) {
        selectedAbx = nonPinnedAbx[0].abx.name; 
        refresh();
      }

      $(window).on('resize', function() {
        updateLayout();
      });

    });
  </script>
</body>
</html>